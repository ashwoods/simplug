{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"simplug A simple plugin system for python with async hooks supported Installation pip install -U simplug Examples A toy example from simplug import Simplug simplug = Simplug ( 'project' ) class MySpec : \"\"\"A hook specification namespace.\"\"\" @simplug . spec def myhook ( self , arg1 , arg2 ): \"\"\"My special little hook that you can customize.\"\"\" class Plugin_1 : \"\"\"A hook implementation namespace.\"\"\" @simplug . impl def myhook ( self , arg1 , arg2 ): print ( \"inside Plugin_1.myhook()\" ) return arg1 + arg2 class Plugin_2 : \"\"\"A 2nd hook implementation namespace.\"\"\" @simplug . impl def myhook ( self , arg1 , arg2 ): print ( \"inside Plugin_2.myhook()\" ) return arg1 - arg2 simplug . register ( Plugin_1 , Plugin_2 ) results = simplug . hooks . myhook ( arg1 = 1 , arg2 = 2 ) print ( results ) inside Plugin_1.myhook() inside Plugin_2.myhook() [3, -1] Note that the hooks are executed in the order the plugins are registered. This is different from pluggy . A complete example See examples/complete/ . Running python -m examples.complete gets us: Your food. Enjoy some egg, egg, egg, salt, pepper, egg, egg Some condiments? We have pickled walnuts, steak sauce, mushy peas, mint sauce After install the plugin: > pip install --editable examples.complete.plugin > python -m examples.complete # run again Your food. Enjoy some egg, egg, egg, salt, pepper, egg, egg, lovely spam, wonderous spam Some condiments? We have pickled walnuts, mushy peas, mint sauce, spam sauce Now this is what I call a condiments tray! Usage Definition of hooks Hooks are specified and implemented by decorating the functions with simplug.spec and simplug.impl respectively. simplug is initialized by: simplug = Simplug ( 'project' ) The 'project' is a unique name to mark the project, which makes sure Simplug('project') get the same instance each time. Note that if simplug is initialized without project , then a name is generated automatically as such project-0 , project-1 , etc. Hook specification is marked by simplug.spec : simplug = Simplug ( 'project' ) @simplug . spec def setup ( args ): ... simplug.spec can take two keyword-arguments: required : Whether this hook is required to be implemented in plugins result : An enumerator to specify the way to collec the results. SimplugResult.ALL: Get all the results from the hook, as a list including NONE s SimplugResult.ALL_BUT_NONE: Get all the results from the hook, as a list, not including NONE s SimplugResult.FIRST: Get the none- None result from the first plugin only (ordered by priority) SimplugResult.LAST: Get the none- None result from the last plugin only Hook implementation is marked by simplug.impl , which takes no additional arguments. The name of the function has to match the name of the function by simplug.spec . And the signatures of the specification function and the implementation function have to be the same in terms of names. This means you can specify default values in the specification function, but you don't have to write the default values in the implementation function. Note that default values in implementation functions will be ignored. Also note if a hook specification is under a namespace, it can take self as argument. However, this argument will be ignored while the hook is being called ( self will be None , and you still have to specify it in the function definition). Loading plugins from setuptools entrypoint You have to call simplug.load_entrypoints(group) after the hook specifications are defined to load the plugins registered by setuptools entrypoint. If group is not given, the project name will be used. The plugin registry The plugins are registered by simplug.register(*plugins) . Each plugin of plugins can be either a python object or a str denoting a module that can be imported by importlib.import_module . The python object must have an attribute name , __name__ or __class.__name__ for simplug to determine the name of the plugin. If the plugin name is determined from __name__ or __class__.__name__ , it will be lowercased. If a plugin is loaded from setuptools entrypoint, then the entrypoint name will be used (no matter what name is defined inside the plugin) You can enable or disable a plugin temporarily after registration by: simplug . disable ( 'plugin_name' ) simplug . enable ( 'plugin_name' ) You can use following methods to inspect the plugin registry: simplug.get_plugin : Get the plugin by name simplug.get_all_plugins : Get a dictionary of name-plugin mappings of all plugins simplug.get_all_plugin_names : Get the names of all plugins, in the order it will be executed. simplug.get_enabled_plugins : Get a dictionary of name-plugin mappings of all enabled plugins simplug.get_enabled_plugin_names : Get the names of all enabled plugins, in the order it will be executed. Calling hooks Hooks are call by simplug.hooks.<hook_name>(<arguments>) and results are collected based on the result argument passed in simplug.spec when defining hooks. Async hooks It makes no big difference to define an async hook: @simplug . spec async def async_hook ( arg ): ... # to supress warnings for sync implementation @simplug . spec ( warn_sync_impl_on_async = False ) async def async_hook ( arg ): ... One can implement this hook in either an async or a sync way. However, when implementing it in a sync way, a warning will be raised. To suppress the warning, one can pass a False value of argument warn_sync_impl_on_async to simplug.spec . To call the async hooks ( simplug.hooks.async_hook(arg) ), you will just need to call it like any other async functions (using asyncio.run , for example) API https://pwwang.github.io/simplug/","title":"Home"},{"location":"#simplug","text":"A simple plugin system for python with async hooks supported","title":"simplug"},{"location":"#installation","text":"pip install -U simplug","title":"Installation"},{"location":"#examples","text":"","title":"Examples"},{"location":"#a-toy-example","text":"from simplug import Simplug simplug = Simplug ( 'project' ) class MySpec : \"\"\"A hook specification namespace.\"\"\" @simplug . spec def myhook ( self , arg1 , arg2 ): \"\"\"My special little hook that you can customize.\"\"\" class Plugin_1 : \"\"\"A hook implementation namespace.\"\"\" @simplug . impl def myhook ( self , arg1 , arg2 ): print ( \"inside Plugin_1.myhook()\" ) return arg1 + arg2 class Plugin_2 : \"\"\"A 2nd hook implementation namespace.\"\"\" @simplug . impl def myhook ( self , arg1 , arg2 ): print ( \"inside Plugin_2.myhook()\" ) return arg1 - arg2 simplug . register ( Plugin_1 , Plugin_2 ) results = simplug . hooks . myhook ( arg1 = 1 , arg2 = 2 ) print ( results ) inside Plugin_1.myhook() inside Plugin_2.myhook() [3, -1] Note that the hooks are executed in the order the plugins are registered. This is different from pluggy .","title":"A toy example"},{"location":"#a-complete-example","text":"See examples/complete/ . Running python -m examples.complete gets us: Your food. Enjoy some egg, egg, egg, salt, pepper, egg, egg Some condiments? We have pickled walnuts, steak sauce, mushy peas, mint sauce After install the plugin: > pip install --editable examples.complete.plugin > python -m examples.complete # run again Your food. Enjoy some egg, egg, egg, salt, pepper, egg, egg, lovely spam, wonderous spam Some condiments? We have pickled walnuts, mushy peas, mint sauce, spam sauce Now this is what I call a condiments tray!","title":"A complete example"},{"location":"#usage","text":"","title":"Usage"},{"location":"#definition-of-hooks","text":"Hooks are specified and implemented by decorating the functions with simplug.spec and simplug.impl respectively. simplug is initialized by: simplug = Simplug ( 'project' ) The 'project' is a unique name to mark the project, which makes sure Simplug('project') get the same instance each time. Note that if simplug is initialized without project , then a name is generated automatically as such project-0 , project-1 , etc. Hook specification is marked by simplug.spec : simplug = Simplug ( 'project' ) @simplug . spec def setup ( args ): ... simplug.spec can take two keyword-arguments: required : Whether this hook is required to be implemented in plugins result : An enumerator to specify the way to collec the results. SimplugResult.ALL: Get all the results from the hook, as a list including NONE s SimplugResult.ALL_BUT_NONE: Get all the results from the hook, as a list, not including NONE s SimplugResult.FIRST: Get the none- None result from the first plugin only (ordered by priority) SimplugResult.LAST: Get the none- None result from the last plugin only Hook implementation is marked by simplug.impl , which takes no additional arguments. The name of the function has to match the name of the function by simplug.spec . And the signatures of the specification function and the implementation function have to be the same in terms of names. This means you can specify default values in the specification function, but you don't have to write the default values in the implementation function. Note that default values in implementation functions will be ignored. Also note if a hook specification is under a namespace, it can take self as argument. However, this argument will be ignored while the hook is being called ( self will be None , and you still have to specify it in the function definition).","title":"Definition of hooks"},{"location":"#loading-plugins-from-setuptools-entrypoint","text":"You have to call simplug.load_entrypoints(group) after the hook specifications are defined to load the plugins registered by setuptools entrypoint. If group is not given, the project name will be used.","title":"Loading plugins from setuptools entrypoint"},{"location":"#the-plugin-registry","text":"The plugins are registered by simplug.register(*plugins) . Each plugin of plugins can be either a python object or a str denoting a module that can be imported by importlib.import_module . The python object must have an attribute name , __name__ or __class.__name__ for simplug to determine the name of the plugin. If the plugin name is determined from __name__ or __class__.__name__ , it will be lowercased. If a plugin is loaded from setuptools entrypoint, then the entrypoint name will be used (no matter what name is defined inside the plugin) You can enable or disable a plugin temporarily after registration by: simplug . disable ( 'plugin_name' ) simplug . enable ( 'plugin_name' ) You can use following methods to inspect the plugin registry: simplug.get_plugin : Get the plugin by name simplug.get_all_plugins : Get a dictionary of name-plugin mappings of all plugins simplug.get_all_plugin_names : Get the names of all plugins, in the order it will be executed. simplug.get_enabled_plugins : Get a dictionary of name-plugin mappings of all enabled plugins simplug.get_enabled_plugin_names : Get the names of all enabled plugins, in the order it will be executed.","title":"The plugin registry"},{"location":"#calling-hooks","text":"Hooks are call by simplug.hooks.<hook_name>(<arguments>) and results are collected based on the result argument passed in simplug.spec when defining hooks.","title":"Calling hooks"},{"location":"#async-hooks","text":"It makes no big difference to define an async hook: @simplug . spec async def async_hook ( arg ): ... # to supress warnings for sync implementation @simplug . spec ( warn_sync_impl_on_async = False ) async def async_hook ( arg ): ... One can implement this hook in either an async or a sync way. However, when implementing it in a sync way, a warning will be raised. To suppress the warning, one can pass a False value of argument warn_sync_impl_on_async to simplug.spec . To call the async hooks ( simplug.hooks.async_hook(arg) ), you will just need to call it like any other async functions (using asyncio.run , for example)","title":"Async hooks"},{"location":"#api","text":"https://pwwang.github.io/simplug/","title":"API"},{"location":"api/simplug/","text":"module simplug </> A simple entrypoint-free plugin system for python Classes SimplugImpl \u2014 A namedtuple wrapper for hook implementation. </> SimplugException \u2014 Base exception class for simplug </> NoSuchPlugin \u2014 When a plugin cannot be imported </> PluginRegistered \u2014 When a plugin with a name already registered </> NoPluginNameDefined \u2014 When the name of the plugin cannot be found </> HookSignatureDifferentFromSpec \u2014 When the hook signature is different from spec </> NoSuchHookSpec \u2014 When implemented a undefined hook or calling a non-exist hook </> HookRequired \u2014 When a required hook is not implemented </> HookSpecExists \u2014 When a hook has already been defined </> SyncImplOnAsyncSpecWarning \u2014 When a sync implementation on an async hook </> SimplugResult \u2014 Way to get the results from the hooks </> SimplugWrapper \u2014 A wrapper for plugin </> SimplugHook \u2014 A hook of a plugin </> SimplugHookAsync \u2014 Wrapper of an async hook </> SimplugHooks \u2014 The hooks manager </> SimplugContext \u2014 The context manager for enabling or disabling a set of plugins </> Simplug ( Simplug ) \u2014 The plugin manager for simplug </> class simplug . SimplugImpl ( impl , has_self ) </> Bases tuple A namedtuple wrapper for hook implementation. This is used to mark the method/function to be an implementation of a hook. Parameters impl \u2014 The hook implementation class simplug . SimplugException ( ) </> Bases Exception BaseException Base exception class for simplug class simplug . NoSuchPlugin ( ) </> Bases simplug.SimplugException Exception BaseException When a plugin cannot be imported class simplug . PluginRegistered ( ) </> Bases simplug.SimplugException Exception BaseException When a plugin with a name already registered class simplug . NoPluginNameDefined ( ) </> Bases simplug.SimplugException Exception BaseException When the name of the plugin cannot be found class simplug . HookSignatureDifferentFromSpec ( ) </> Bases simplug.SimplugException Exception BaseException When the hook signature is different from spec class simplug . NoSuchHookSpec ( ) </> Bases simplug.SimplugException Exception BaseException When implemented a undefined hook or calling a non-exist hook class simplug . HookRequired ( ) </> Bases simplug.SimplugException Exception BaseException When a required hook is not implemented class simplug . HookSpecExists ( ) </> Bases simplug.SimplugException Exception BaseException When a hook has already been defined class simplug . SyncImplOnAsyncSpecWarning ( ) </> Bases Warning Exception BaseException When a sync implementation on an async hook class simplug . SimplugResult ( value , names=None , module=None , qualname=None , type=None , start=1 ) </> Bases enum.Enum Way to get the results from the hooks Attributes ALL \u2014 Get all the results from the hook, as a list including NONE s ALL_BUT_NONE \u2014 Get all the results from the hook, as a list not including NONE s FIRST \u2014 Get the none- None result from the first plugin only (ordered by priority) LAST \u2014 Get the none- None result from the last plugin only Classes EnumMeta \u2014 Metaclass for Enum </> class enum. EnumMeta ( cls , bases , classdict ) </> Metaclass for Enum Attributes __members__ \u2014 Returns a mapping of member name->value. This mapping lists all enum members, including aliases. Note that this is a read-only view of the internal mapping. </> Methods __bool__ ( ) \u2014 classes/types should always be True. </> __call__ ( cls , value , names , module , qualname , type , start ) \u2014 Either returns an existing member, or creates a new enum class. </> __dir__ ( ) \u2014 Specialized dir implementation for types. </> __getattr__ ( cls , name ) \u2014 Return the enum member matching name </> __setattr__ ( cls , name , value ) \u2014 Block attempts to reassign Enum members. </> method __bool__ ( ) </> classes/types should always be True. staticmethod __call__ ( cls , value , names=None , module=None , qualname=None , type=None , start=1 ) </> Either returns an existing member, or creates a new enum class. This method is used both when an enum class is given a value to match to an enumeration member (i.e. Color(3)) and for the functional API (i.e. Color = Enum('Color', names='RED GREEN BLUE')). When used for the functional API: value will be the name of the new class. names should be either a string of white-space/comma delimited names (values will start at start ), or an iterator/mapping of name, value pairs. module should be set to the module this class is being created in; if it is not set, an attempt to find that module will be made, but if it fails the class will not be picklable. qualname should be set to the actual location this class can be found at in its module; by default it is set to the global scope. If this is not correct, unpickling will fail in some circumstances. type , if set, will be mixed in as the first base class. method __dir__ ( ) </> Specialized dir implementation for types. staticmethod __getattr__ ( cls , name ) </> Return the enum member matching name We use getattr instead of descriptors or inserting into the enum class' dict in order to support name and value being both properties for enum members (which live in the class' dict ) and enum members themselves. staticmethod __setattr__ ( cls , name , value ) </> Block attempts to reassign Enum members. A simple assignment to the class namespace only changes one of the several possible ways to get an Enum member from the Enum class, resulting in an inconsistent Enumeration. class simplug . SimplugWrapper ( plugin , batch_index , index ) </> A wrapper for plugin Parameters plugin (any) \u2014 A object or a string indicating the plugin as a module batch_index (int) \u2014 The batch_index when the plugin is registered simplug = Simplug() simplug.register('plugin1', 'plugin2') # batch 0 # index:0, index:1 simplug.register('plugin3', 'plugin4') # batch 1 # index:0, index:1 index (int) \u2014 The index when the plugin is registered Attributes name \u2014 Try to get the name of the plugin. A lowercase name is recommended. if <plugin>.name is defined, then the name is used. Otherwise, <plugin>.__name__ is used. Finally, <plugin>.__class__.__name__ is tried. </> plugin \u2014 The raw plugin object priority \u2014 A 2-element tuple used to prioritize the plugins - If plugin.priority is specified, use it as the first element and batch_index will be the second element - Otherwise, batch_index the first and index the second. - Smaller number has higher priority - Negative numbers allowed version \u2014 Try to get the version of the plugin. If the attribute version is definied, use it. Otherwise, try to check if __version__ is defined. If neither is defined, return None. </> version \u2014 Try to get the version of the plugin. If the attribute version is definied, use it. Otherwise, try to check if __version__ is defined. If neither is defined, return None. </> Raises NoSuchPlugin \u2014 When a string is passed in and the plugin cannot be imported as a module Methods disable ( ) \u2014 Disable this plugin </> enable ( ) \u2014 Enable this plugin </> hook ( name ) ( SimplugImpl , optional) \u2014 Get the hook implementation of this plugin by name </> method enable ( ) </> Enable this plugin method disable ( ) </> Disable this plugin method hook ( name ) </> Get the hook implementation of this plugin by name Parameters name (str) \u2014 The name of the hook Returns ( SimplugImpl , optional) The wrapper of the implementation. If the implementation is not found or it's not decorated by simplug.impl , None will be returned. class simplug . SimplugHook ( simplug_hooks , spec , required , result , warn_sync_impl_on_async=False ) </> A hook of a plugin Parameters simplug_hooks ( SimplugHooks ) \u2014 The SimplugHooks object spec (callable) \u2014 The specification of the hook required (bool) \u2014 Whether this hook is required to be implemented result ( SimplugResult ) \u2014 Way to collect the results from the hook Attributes _has_self \u2014 Whether the parameters have self as the first. If so, it will be ignored while being called. name \u2014 The name of the hook required \u2014 Whether this hook is required to be implemented result \u2014 Way to collect the results from the hook simplug_hooks \u2014 The SimplugHooks object spec \u2014 The specification of the hook Methods __call__ ( *args , **kwargs ) (Depending on `self.result`) \u2014 Call the hook in your system </> method __call__ ( *args , **kwargs ) </> Call the hook in your system Parameters *args \u2014 args for the hook **kwargs \u2014 kwargs for the hook Returns (Depending on `self.result`) t s , s e ) m y class simplug . SimplugHookAsync ( simplug_hooks , spec , required , result , warn_sync_impl_on_async=False ) </> Bases simplug.SimplugHook Wrapper of an async hook Parameters simplug_hooks ( SimplugHooks ) \u2014 The SimplugHooks object spec (callable) \u2014 The specification of the hook required (bool) \u2014 Whether this hook is required to be implemented result ( SimplugResult ) \u2014 Way to collect the results from the hook Attributes _has_self \u2014 Whether the parameters have self as the first. If so, it will be ignored while being called. name \u2014 The name of the hook required \u2014 Whether this hook is required to be implemented result \u2014 Way to collect the results from the hook simplug_hooks \u2014 The SimplugHooks object spec \u2014 The specification of the hook Methods __call__ ( *args , **kwargs ) (Depending on `self.result`) \u2014 Call the hook in your system asynchronously </> method __call__ ( *args , **kwargs ) </> Call the hook in your system asynchronously Parameters *args \u2014 args for the hook **kwargs \u2014 kwargs for the hook Returns (Depending on `self.result`) t s , s e ) m y class simplug . SimplugHooks ( ) </> The hooks manager Methods in this class are prefixed with a underscore to attributes clean for hooks. To call a hook in your system: >>> simplug . hooks .< hook_name > ( < args > ) Attributes _registry \u2014 The plugin registry _registry_sorted \u2014 Whether the plugin registry has been sorted already _specs \u2014 The registry for the hook specs Methods __getattr__ ( name ) ( SimplugHook ) \u2014 Get the hook by name </> method __getattr__ ( name ) </> Get the hook by name Parameters name (str) \u2014 The hook name Returns ( SimplugHook ) The SimplugHook object Raises NoSuchHookSpec \u2014 When the hook has no specification defined. class simplug . SimplugContext ( simplug , plugins ) </> The context manager for enabling or disabling a set of plugins class simplug . Simplug ( project ) \u2192 Simplug </> The plugin manager for simplug Attributes PROJECTS \u2014 The projects registry, to make sure the same Simplug object by the name project name. _batch_index \u2014 The batch index for plugin registration _inited \u2014 Whether __init__ has already been called. Since the __init__ method will be called after __new__ , this is used to avoid __init__ to be called more than once hooks \u2014 The hooks manager Methods disable ( *names ) \u2014 Disable plugins by names </> enable ( *names ) \u2014 Enable plugins by names </> get_all_plugin_names ( ) (list of str) \u2014 Get the names of all plugins </> get_all_plugins ( raw ) (dict(str: SimplugWrapper )) \u2014 Get a mapping of all plugins </> get_enabled_plugin_names ( ) (list of str) \u2014 Get the names of all enabled plugins </> get_enabled_plugins ( raw ) (dict(str: SimplugWrapper )) \u2014 Get a mapping of all enabled plugins </> get_plugin ( name , raw ) (object) \u2014 Get the plugin wrapper or the raw plugin object </> impl ( hook ) \u2014 A decorator for the implementation of a hook </> load_entrypoints ( group ) \u2014 Load plugins from setuptools entry_points </> plugins_but_context ( plugins ) (_SimplugContextBut) \u2014 A context manager with all plugins but given plugins enabled </> plugins_only_context ( plugins ) (_SimplugContextOnly) \u2014 A context manager with only given plugins enabled </> register ( *plugins ) \u2014 Register plugins </> spec ( hook , required , result , warn_sync_impl_on_async ) (callable) \u2014 A decorator to define the specification of a hook </> method load_entrypoints ( group=None ) </> Load plugins from setuptools entry_points method register ( *plugins ) </> Register plugins Parameters *plugins (any) \u2014 The plugins, each of which could be a str, indicating that the plugin is a module and will be imported by __import__ ; or an object with the hook implementations as its attributes. method get_plugin ( name , raw=False ) </> Get the plugin wrapper or the raw plugin object Parameters name (str) \u2014 The name of the plugin raw (bool, optional) \u2014 Get the raw plugin object (the one when it's registered) If a plugin is a module and registered by its name, the module is returned Raises NoSuchPlugin \u2014 When the plugin does not exist Returns (object) The plugin wrapper or raw plugin method get_all_plugins ( raw=False ) </> Get a mapping of all plugins Parameters raw (bool, optional) \u2014 Whether return the raw plugin or not (the one when it's registered) If a plugin is registered as a module by its name, the module is returned. Returns (dict(str: SimplugWrapper )) The mapping of all plugins method get_enabled_plugins ( raw=False ) </> Get a mapping of all enabled plugins Parameters raw (bool, optional) \u2014 Whether return the raw plugin or not (the one when it's registered) If a plugin is registered as a module by its name, the module is returned. Returns (dict(str: SimplugWrapper )) The mapping of all enabled plugins method get_all_plugin_names ( ) </> Get the names of all plugins Returns (list of str) The names of all plugins method get_enabled_plugin_names ( ) </> Get the names of all enabled plugins Returns (list of str) The names of all enabled plugins method plugins_only_context ( plugins ) </> A context manager with only given plugins enabled Parameters plugins (iterable of any, optional) \u2014 The plugin names or plugin objects If the given plugin does not exist, register it. None to not enable or disable anything Returns (_SimplugContextOnly) The context manager method plugins_but_context ( plugins ) </> A context manager with all plugins but given plugins enabled Parameters *plugins \u2014 The plugin names or plugin objects to exclude If the given plugin does not exist, ignore it Returns (_SimplugContextBut) The context manager method enable ( *names ) </> Enable plugins by names Parameters *names (str) \u2014 The names of the plugin method disable ( *names ) </> Disable plugins by names Parameters names \u2014 The names of the plugin method spec ( hook=None , required=False , result=<SimplugResult.ALL_BUT_NONE: 'all_but_none'> , warn_sync_impl_on_async=True ) </> A decorator to define the specification of a hook Parameters hook (callable, optional) \u2014 The hook spec. If it is None, that means this decorator is called with arguments, and it should be keyword arguments. Otherwise, it is called like this simplug.spec required (bool, optional) \u2014 Whether this hook is required to be implemented. result ( SimplugResult , optional) \u2014 How should we collect the results from the plugins Raises HookSpecExists \u2014 If a hook spec with the same name ( hook.__name__ ) is already defined. Returns (callable) A decorator function of other argument is passed, or the hook spec itself. method impl ( hook ) </> A decorator for the implementation of a hook Parameters hook (callable) \u2014 The hook implementation Raises NoSuchHookSpec \u2014 When no specification is defined for this hook Returns The wrapped hook implementation by SimplugImpl","title":"API"},{"location":"api/simplug/#simplug","text":"</> A simple entrypoint-free plugin system for python Classes SimplugImpl \u2014 A namedtuple wrapper for hook implementation. </> SimplugException \u2014 Base exception class for simplug </> NoSuchPlugin \u2014 When a plugin cannot be imported </> PluginRegistered \u2014 When a plugin with a name already registered </> NoPluginNameDefined \u2014 When the name of the plugin cannot be found </> HookSignatureDifferentFromSpec \u2014 When the hook signature is different from spec </> NoSuchHookSpec \u2014 When implemented a undefined hook or calling a non-exist hook </> HookRequired \u2014 When a required hook is not implemented </> HookSpecExists \u2014 When a hook has already been defined </> SyncImplOnAsyncSpecWarning \u2014 When a sync implementation on an async hook </> SimplugResult \u2014 Way to get the results from the hooks </> SimplugWrapper \u2014 A wrapper for plugin </> SimplugHook \u2014 A hook of a plugin </> SimplugHookAsync \u2014 Wrapper of an async hook </> SimplugHooks \u2014 The hooks manager </> SimplugContext \u2014 The context manager for enabling or disabling a set of plugins </> Simplug ( Simplug ) \u2014 The plugin manager for simplug </> class","title":"simplug"},{"location":"api/simplug/#simplugsimplugimpl","text":"</> Bases tuple A namedtuple wrapper for hook implementation. This is used to mark the method/function to be an implementation of a hook. Parameters impl \u2014 The hook implementation class","title":"simplug.SimplugImpl"},{"location":"api/simplug/#simplugsimplugexception","text":"</> Bases Exception BaseException Base exception class for simplug class","title":"simplug.SimplugException"},{"location":"api/simplug/#simplugnosuchplugin","text":"</> Bases simplug.SimplugException Exception BaseException When a plugin cannot be imported class","title":"simplug.NoSuchPlugin"},{"location":"api/simplug/#simplugpluginregistered","text":"</> Bases simplug.SimplugException Exception BaseException When a plugin with a name already registered class","title":"simplug.PluginRegistered"},{"location":"api/simplug/#simplugnopluginnamedefined","text":"</> Bases simplug.SimplugException Exception BaseException When the name of the plugin cannot be found class","title":"simplug.NoPluginNameDefined"},{"location":"api/simplug/#simplughooksignaturedifferentfromspec","text":"</> Bases simplug.SimplugException Exception BaseException When the hook signature is different from spec class","title":"simplug.HookSignatureDifferentFromSpec"},{"location":"api/simplug/#simplugnosuchhookspec","text":"</> Bases simplug.SimplugException Exception BaseException When implemented a undefined hook or calling a non-exist hook class","title":"simplug.NoSuchHookSpec"},{"location":"api/simplug/#simplughookrequired","text":"</> Bases simplug.SimplugException Exception BaseException When a required hook is not implemented class","title":"simplug.HookRequired"},{"location":"api/simplug/#simplughookspecexists","text":"</> Bases simplug.SimplugException Exception BaseException When a hook has already been defined class","title":"simplug.HookSpecExists"},{"location":"api/simplug/#simplugsyncimplonasyncspecwarning","text":"</> Bases Warning Exception BaseException When a sync implementation on an async hook class","title":"simplug.SyncImplOnAsyncSpecWarning"},{"location":"api/simplug/#simplugsimplugresult","text":"</> Bases enum.Enum Way to get the results from the hooks Attributes ALL \u2014 Get all the results from the hook, as a list including NONE s ALL_BUT_NONE \u2014 Get all the results from the hook, as a list not including NONE s FIRST \u2014 Get the none- None result from the first plugin only (ordered by priority) LAST \u2014 Get the none- None result from the last plugin only Classes EnumMeta \u2014 Metaclass for Enum </> class","title":"simplug.SimplugResult"},{"location":"api/simplug/#enumenummeta","text":"</> Metaclass for Enum Attributes __members__ \u2014 Returns a mapping of member name->value. This mapping lists all enum members, including aliases. Note that this is a read-only view of the internal mapping. </> Methods __bool__ ( ) \u2014 classes/types should always be True. </> __call__ ( cls , value , names , module , qualname , type , start ) \u2014 Either returns an existing member, or creates a new enum class. </> __dir__ ( ) \u2014 Specialized dir implementation for types. </> __getattr__ ( cls , name ) \u2014 Return the enum member matching name </> __setattr__ ( cls , name , value ) \u2014 Block attempts to reassign Enum members. </> method __bool__ ( ) </> classes/types should always be True. staticmethod __call__ ( cls , value , names=None , module=None , qualname=None , type=None , start=1 ) </> Either returns an existing member, or creates a new enum class. This method is used both when an enum class is given a value to match to an enumeration member (i.e. Color(3)) and for the functional API (i.e. Color = Enum('Color', names='RED GREEN BLUE')). When used for the functional API: value will be the name of the new class. names should be either a string of white-space/comma delimited names (values will start at start ), or an iterator/mapping of name, value pairs. module should be set to the module this class is being created in; if it is not set, an attempt to find that module will be made, but if it fails the class will not be picklable. qualname should be set to the actual location this class can be found at in its module; by default it is set to the global scope. If this is not correct, unpickling will fail in some circumstances. type , if set, will be mixed in as the first base class. method __dir__ ( ) </> Specialized dir implementation for types. staticmethod __getattr__ ( cls , name ) </> Return the enum member matching name We use getattr instead of descriptors or inserting into the enum class' dict in order to support name and value being both properties for enum members (which live in the class' dict ) and enum members themselves. staticmethod __setattr__ ( cls , name , value ) </> Block attempts to reassign Enum members. A simple assignment to the class namespace only changes one of the several possible ways to get an Enum member from the Enum class, resulting in an inconsistent Enumeration. class","title":"enum.EnumMeta"},{"location":"api/simplug/#simplugsimplugwrapper","text":"</> A wrapper for plugin Parameters plugin (any) \u2014 A object or a string indicating the plugin as a module batch_index (int) \u2014 The batch_index when the plugin is registered simplug = Simplug() simplug.register('plugin1', 'plugin2') # batch 0 # index:0, index:1 simplug.register('plugin3', 'plugin4') # batch 1 # index:0, index:1 index (int) \u2014 The index when the plugin is registered Attributes name \u2014 Try to get the name of the plugin. A lowercase name is recommended. if <plugin>.name is defined, then the name is used. Otherwise, <plugin>.__name__ is used. Finally, <plugin>.__class__.__name__ is tried. </> plugin \u2014 The raw plugin object priority \u2014 A 2-element tuple used to prioritize the plugins - If plugin.priority is specified, use it as the first element and batch_index will be the second element - Otherwise, batch_index the first and index the second. - Smaller number has higher priority - Negative numbers allowed version \u2014 Try to get the version of the plugin. If the attribute version is definied, use it. Otherwise, try to check if __version__ is defined. If neither is defined, return None. </> version \u2014 Try to get the version of the plugin. If the attribute version is definied, use it. Otherwise, try to check if __version__ is defined. If neither is defined, return None. </> Raises NoSuchPlugin \u2014 When a string is passed in and the plugin cannot be imported as a module Methods disable ( ) \u2014 Disable this plugin </> enable ( ) \u2014 Enable this plugin </> hook ( name ) ( SimplugImpl , optional) \u2014 Get the hook implementation of this plugin by name </> method","title":"simplug.SimplugWrapper"},{"location":"api/simplug/#simplugsimplugwrapperenable","text":"</> Enable this plugin method","title":"simplug.SimplugWrapper.enable"},{"location":"api/simplug/#simplugsimplugwrapperdisable","text":"</> Disable this plugin method","title":"simplug.SimplugWrapper.disable"},{"location":"api/simplug/#simplugsimplugwrapperhook","text":"</> Get the hook implementation of this plugin by name Parameters name (str) \u2014 The name of the hook Returns ( SimplugImpl , optional) The wrapper of the implementation. If the implementation is not found or it's not decorated by simplug.impl , None will be returned. class","title":"simplug.SimplugWrapper.hook"},{"location":"api/simplug/#simplugsimplughook","text":"</> A hook of a plugin Parameters simplug_hooks ( SimplugHooks ) \u2014 The SimplugHooks object spec (callable) \u2014 The specification of the hook required (bool) \u2014 Whether this hook is required to be implemented result ( SimplugResult ) \u2014 Way to collect the results from the hook Attributes _has_self \u2014 Whether the parameters have self as the first. If so, it will be ignored while being called. name \u2014 The name of the hook required \u2014 Whether this hook is required to be implemented result \u2014 Way to collect the results from the hook simplug_hooks \u2014 The SimplugHooks object spec \u2014 The specification of the hook Methods __call__ ( *args , **kwargs ) (Depending on `self.result`) \u2014 Call the hook in your system </> method","title":"simplug.SimplugHook"},{"location":"api/simplug/#simplugsimplughookcall","text":"</> Call the hook in your system Parameters *args \u2014 args for the hook **kwargs \u2014 kwargs for the hook Returns (Depending on `self.result`) t s , s e ) m y class","title":"simplug.SimplugHook.call"},{"location":"api/simplug/#simplugsimplughookasync","text":"</> Bases simplug.SimplugHook Wrapper of an async hook Parameters simplug_hooks ( SimplugHooks ) \u2014 The SimplugHooks object spec (callable) \u2014 The specification of the hook required (bool) \u2014 Whether this hook is required to be implemented result ( SimplugResult ) \u2014 Way to collect the results from the hook Attributes _has_self \u2014 Whether the parameters have self as the first. If so, it will be ignored while being called. name \u2014 The name of the hook required \u2014 Whether this hook is required to be implemented result \u2014 Way to collect the results from the hook simplug_hooks \u2014 The SimplugHooks object spec \u2014 The specification of the hook Methods __call__ ( *args , **kwargs ) (Depending on `self.result`) \u2014 Call the hook in your system asynchronously </> method","title":"simplug.SimplugHookAsync"},{"location":"api/simplug/#simplugsimplughookasynccall","text":"</> Call the hook in your system asynchronously Parameters *args \u2014 args for the hook **kwargs \u2014 kwargs for the hook Returns (Depending on `self.result`) t s , s e ) m y class","title":"simplug.SimplugHookAsync.call"},{"location":"api/simplug/#simplugsimplughooks","text":"</> The hooks manager Methods in this class are prefixed with a underscore to attributes clean for hooks. To call a hook in your system: >>> simplug . hooks .< hook_name > ( < args > ) Attributes _registry \u2014 The plugin registry _registry_sorted \u2014 Whether the plugin registry has been sorted already _specs \u2014 The registry for the hook specs Methods __getattr__ ( name ) ( SimplugHook ) \u2014 Get the hook by name </> method","title":"simplug.SimplugHooks"},{"location":"api/simplug/#simplugsimplughooksgetattr","text":"</> Get the hook by name Parameters name (str) \u2014 The hook name Returns ( SimplugHook ) The SimplugHook object Raises NoSuchHookSpec \u2014 When the hook has no specification defined. class","title":"simplug.SimplugHooks.getattr"},{"location":"api/simplug/#simplugsimplugcontext","text":"</> The context manager for enabling or disabling a set of plugins class","title":"simplug.SimplugContext"},{"location":"api/simplug/#simplugsimplug","text":"</> The plugin manager for simplug Attributes PROJECTS \u2014 The projects registry, to make sure the same Simplug object by the name project name. _batch_index \u2014 The batch index for plugin registration _inited \u2014 Whether __init__ has already been called. Since the __init__ method will be called after __new__ , this is used to avoid __init__ to be called more than once hooks \u2014 The hooks manager Methods disable ( *names ) \u2014 Disable plugins by names </> enable ( *names ) \u2014 Enable plugins by names </> get_all_plugin_names ( ) (list of str) \u2014 Get the names of all plugins </> get_all_plugins ( raw ) (dict(str: SimplugWrapper )) \u2014 Get a mapping of all plugins </> get_enabled_plugin_names ( ) (list of str) \u2014 Get the names of all enabled plugins </> get_enabled_plugins ( raw ) (dict(str: SimplugWrapper )) \u2014 Get a mapping of all enabled plugins </> get_plugin ( name , raw ) (object) \u2014 Get the plugin wrapper or the raw plugin object </> impl ( hook ) \u2014 A decorator for the implementation of a hook </> load_entrypoints ( group ) \u2014 Load plugins from setuptools entry_points </> plugins_but_context ( plugins ) (_SimplugContextBut) \u2014 A context manager with all plugins but given plugins enabled </> plugins_only_context ( plugins ) (_SimplugContextOnly) \u2014 A context manager with only given plugins enabled </> register ( *plugins ) \u2014 Register plugins </> spec ( hook , required , result , warn_sync_impl_on_async ) (callable) \u2014 A decorator to define the specification of a hook </> method","title":"simplug.Simplug"},{"location":"api/simplug/#simplugsimplugload_entrypoints","text":"</> Load plugins from setuptools entry_points method","title":"simplug.Simplug.load_entrypoints"},{"location":"api/simplug/#simplugsimplugregister","text":"</> Register plugins Parameters *plugins (any) \u2014 The plugins, each of which could be a str, indicating that the plugin is a module and will be imported by __import__ ; or an object with the hook implementations as its attributes. method","title":"simplug.Simplug.register"},{"location":"api/simplug/#simplugsimplugget_plugin","text":"</> Get the plugin wrapper or the raw plugin object Parameters name (str) \u2014 The name of the plugin raw (bool, optional) \u2014 Get the raw plugin object (the one when it's registered) If a plugin is a module and registered by its name, the module is returned Raises NoSuchPlugin \u2014 When the plugin does not exist Returns (object) The plugin wrapper or raw plugin method","title":"simplug.Simplug.get_plugin"},{"location":"api/simplug/#simplugsimplugget_all_plugins","text":"</> Get a mapping of all plugins Parameters raw (bool, optional) \u2014 Whether return the raw plugin or not (the one when it's registered) If a plugin is registered as a module by its name, the module is returned. Returns (dict(str: SimplugWrapper )) The mapping of all plugins method","title":"simplug.Simplug.get_all_plugins"},{"location":"api/simplug/#simplugsimplugget_enabled_plugins","text":"</> Get a mapping of all enabled plugins Parameters raw (bool, optional) \u2014 Whether return the raw plugin or not (the one when it's registered) If a plugin is registered as a module by its name, the module is returned. Returns (dict(str: SimplugWrapper )) The mapping of all enabled plugins method","title":"simplug.Simplug.get_enabled_plugins"},{"location":"api/simplug/#simplugsimplugget_all_plugin_names","text":"</> Get the names of all plugins Returns (list of str) The names of all plugins method","title":"simplug.Simplug.get_all_plugin_names"},{"location":"api/simplug/#simplugsimplugget_enabled_plugin_names","text":"</> Get the names of all enabled plugins Returns (list of str) The names of all enabled plugins method","title":"simplug.Simplug.get_enabled_plugin_names"},{"location":"api/simplug/#simplugsimplugplugins_only_context","text":"</> A context manager with only given plugins enabled Parameters plugins (iterable of any, optional) \u2014 The plugin names or plugin objects If the given plugin does not exist, register it. None to not enable or disable anything Returns (_SimplugContextOnly) The context manager method","title":"simplug.Simplug.plugins_only_context"},{"location":"api/simplug/#simplugsimplugplugins_but_context","text":"</> A context manager with all plugins but given plugins enabled Parameters *plugins \u2014 The plugin names or plugin objects to exclude If the given plugin does not exist, ignore it Returns (_SimplugContextBut) The context manager method","title":"simplug.Simplug.plugins_but_context"},{"location":"api/simplug/#simplugsimplugenable","text":"</> Enable plugins by names Parameters *names (str) \u2014 The names of the plugin method","title":"simplug.Simplug.enable"},{"location":"api/simplug/#simplugsimplugdisable","text":"</> Disable plugins by names Parameters names \u2014 The names of the plugin method","title":"simplug.Simplug.disable"},{"location":"api/simplug/#simplugsimplugspec","text":"</> A decorator to define the specification of a hook Parameters hook (callable, optional) \u2014 The hook spec. If it is None, that means this decorator is called with arguments, and it should be keyword arguments. Otherwise, it is called like this simplug.spec required (bool, optional) \u2014 Whether this hook is required to be implemented. result ( SimplugResult , optional) \u2014 How should we collect the results from the plugins Raises HookSpecExists \u2014 If a hook spec with the same name ( hook.__name__ ) is already defined. Returns (callable) A decorator function of other argument is passed, or the hook spec itself. method","title":"simplug.Simplug.spec"},{"location":"api/simplug/#simplugsimplugimpl_1","text":"</> A decorator for the implementation of a hook Parameters hook (callable) \u2014 The hook implementation Raises NoSuchHookSpec \u2014 When no specification is defined for this hook Returns The wrapped hook implementation by SimplugImpl","title":"simplug.Simplug.impl"},{"location":"api/source/simplug/","text":"SOURCE CODE simplug DOCS \"\"\"A simple entrypoint-free plugin system for python\"\"\" from typing import Any , Callable , Dict , Iterable , List , Optional , Tuple import inspect import warnings from importlib import import_module from collections import namedtuple from enum import Enum from diot import OrderedDiot try : # pragma: no cover import importlib_metadata except ImportError : # pragma: no cover # pylint: disable=ungrouped-imports from importlib import metadata as importlib_metadata __version__ = '0.0.6' SimplugImpl = namedtuple ( 'SimplugImpl' , [ 'impl' , 'has_self' ]) SimplugImpl . __doc__ = \"\"\"A namedtuple wrapper for hook implementation. This is used to mark the method/function to be an implementation of a hook. Args: impl: The hook implementation \"\"\" class SimplugException ( Exception ): DOCS \"\"\"Base exception class for simplug\"\"\" class NoSuchPlugin ( SimplugException ): DOCS \"\"\"When a plugin cannot be imported\"\"\" class PluginRegistered ( SimplugException ): DOCS \"\"\"When a plugin with a name already registered\"\"\" class NoPluginNameDefined ( SimplugException ): DOCS \"\"\"When the name of the plugin cannot be found\"\"\" class HookSignatureDifferentFromSpec ( SimplugException ): DOCS \"\"\"When the hook signature is different from spec\"\"\" class NoSuchHookSpec ( SimplugException ): DOCS \"\"\"When implemented a undefined hook or calling a non-exist hook\"\"\" class HookRequired ( SimplugException ): DOCS \"\"\"When a required hook is not implemented\"\"\" class HookSpecExists ( SimplugException ): DOCS \"\"\"When a hook has already been defined\"\"\" class SyncImplOnAsyncSpecWarning ( Warning ): DOCS \"\"\"When a sync implementation on an async hook\"\"\" class SimplugResult ( Enum ): DOCS \"\"\"Way to get the results from the hooks Attributes: ALL: Get all the results from the hook, as a list including `NONE`s ALL_BUT_NONE: Get all the results from the hook, as a list not including `NONE`s FIRST: Get the none-`None` result from the first plugin only (ordered by priority) LAST: Get the none-`None` result from the last plugin only \"\"\" ALL = 'all' ALL_BUT_NONE = 'all_but_none' FIRST = 'first' LAST = 'last' class SimplugWrapper : DOCS \"\"\"A wrapper for plugin Args: plugin: A object or a string indicating the plugin as a module batch_index: The batch_index when the plugin is registered >>> simplug = Simplug() >>> simplug.register('plugin1', 'plugin2') # batch 0 >>> # index:0, index:1 >>> simplug.register('plugin3', 'plugin4') # batch 1 >>> # index:0, index:1 index: The index when the plugin is registered Attributes: plugin: The raw plugin object priority: A 2-element tuple used to prioritize the plugins - If `plugin.priority` is specified, use it as the first element and batch_index will be the second element - Otherwise, batch_index the first and index the second. - Smaller number has higher priority - Negative numbers allowed Raises: NoSuchPlugin: When a string is passed in and the plugin cannot be imported as a module \"\"\" def __init__ ( self , plugin : Any , batch_index : int , index : int ): self . plugin = self . _name = None if isinstance ( plugin , str ): try : self . plugin = import_module ( plugin ) except ImportError as exc : raise NoSuchPlugin ( plugin ) . with_traceback ( exc . __traceback__ ) from None elif isinstance ( plugin , tuple ): # plugin load from entrypoint # name specified as second element explicitly self . plugin , self . _name = plugin else : self . plugin = plugin priority = getattr ( self . plugin , 'priority' , None ) self . priority = (( batch_index , index ) if priority is None else ( priority , batch_index )) # type: Tuple[int, int] self . enabled = True # type: bool @property DOCS def version ( self ) -> Optional [ str ]: \"\"\"Try to get the version of the plugin. If the attribute `version` is definied, use it. Otherwise, try to check if `__version__` is defined. If neither is defined, return None. Returns: In the priority order of plugin.version, plugin.__version__ and None \"\"\" return getattr ( self . plugin , 'version' , getattr ( self . plugin , '__version__' , None )) __version__ = version @property DOCS def name ( self ) -> str : \"\"\"Try to get the name of the plugin. A lowercase name is recommended. if `<plugin>.name` is defined, then the name is used. Otherwise, `<plugin>.__name__` is used. Finally, `<plugin>.__class__.__name__` is tried. Raises: NoPluginNameDefined: When a name cannot be retrieved. Returns: The name of the plugin \"\"\" if self . _name is not None : return self . _name try : return self . plugin . name except AttributeError : pass try : return self . plugin . __name__ . lower () except AttributeError : pass try : return self . plugin . __class__ . __name__ . lower () except AttributeError : # pragma: no cover pass raise NoPluginNameDefined ( str ( self . plugin )) # pragma: no cover def enable ( self ) -> None : DOCS \"\"\"Enable this plugin\"\"\" self . enabled = True def disable ( self ): DOCS \"\"\"Disable this plugin\"\"\" self . enabled = False def hook ( self , name : str ) -> Optional [ SimplugImpl ]: DOCS \"\"\"Get the hook implementation of this plugin by name Args: name: The name of the hook Returns: The wrapper of the implementation. If the implementation is not found or it's not decorated by `simplug.impl`, None will be returned. \"\"\" ret = getattr ( self . plugin , name , None ) if not isinstance ( ret , SimplugImpl ): return None return ret def __eq__ ( self , other : Any ) -> bool : if not isinstance ( other , self . __class__ ): return False return self . plugin is other . plugin def __ne__ ( self , other : Any ) -> bool : return not self . __eq__ ( other ) class SimplugHook : DOCS \"\"\"A hook of a plugin Args: simplug_hooks: The SimplugHooks object spec: The specification of the hook required: Whether this hook is required to be implemented result: Way to collect the results from the hook Attributes: name: The name of the hook simplug_hooks: The SimplugHooks object spec: The specification of the hook required: Whether this hook is required to be implemented result: Way to collect the results from the hook _has_self: Whether the parameters have `self` as the first. If so, it will be ignored while being called. \"\"\" def __init__ ( self , # pylint: disable=too-many-arguments simplug_hooks : \"SimplugHooks\" , spec : Callable , required : bool , result : SimplugResult , warn_sync_impl_on_async : bool = False ): self . simplug_hooks = simplug_hooks self . spec = spec self . name = spec . __name__ self . required = required self . result = result self . warn_sync_impl_on_async = warn_sync_impl_on_async def _get_results ( self , results : List [ Any ]) -> Any : \"\"\"Get the results according to self.result\"\"\" if self . result == SimplugResult . ALL : return results results = [ result for result in results if result is not None ] if self . result == SimplugResult . FIRST : return results [ 0 ] if results else None if self . result == SimplugResult . LAST : return results [ - 1 ] if results else None # ALL_BUT_NONE return results def __call__ ( self , * args , ** kwargs ): DOCS \"\"\"Call the hook in your system Args: *args: args for the hook **kwargs: kwargs for the hook Returns: Depending on `self.result`: - SimplugResult.ALL: Get all the results from the hook, as a list including `NONE`s - SimplugResult.ALL_BUT_NONE: Get all the results from the hook, as a list, not including `NONE`s - SimplugResult.FIRST: Get the none-`None` result from the first plugin only (ordered by priority) - SimplugResult.LAST: Get the none-`None` result from the last plugin only \"\"\" self . simplug_hooks . _sort_registry () results = [] for plugin in self . simplug_hooks . _registry . values (): if not plugin . enabled : continue hook = plugin . hook ( self . name ) if hook is not None : plugin_args = ( plugin . plugin , * args ) if hook . has_self else args results . append ( hook . impl ( * plugin_args , ** kwargs )) return self . _get_results ( results ) class SimplugHookAsync ( SimplugHook ): DOCS \"\"\"Wrapper of an async hook\"\"\" # invalid-overridden-method # pylint: disable=bad-option-value,W0236 async def __call__ ( self , * args , ** kwargs ): DOCS \"\"\"Call the hook in your system asynchronously Args: *args: args for the hook **kwargs: kwargs for the hook Returns: Depending on `self.result`: - SimplugResult.ALL: Get all the results from the hook, as a list including `NONE`s - SimplugResult.ALL_BUT_NONE: Get all the results from the hook, as a list, not including `NONE`s - SimplugResult.FIRST: Get the none-`None` result from the first plugin only (ordered by priority) - SimplugResult.LAST: Get the none-`None` result from the last plugin only \"\"\" self . simplug_hooks . _sort_registry () results = [] for plugin in self . simplug_hooks . _registry . values (): if not plugin . enabled : continue hook = plugin . hook ( self . name ) if hook is None : continue plugin_args = ( plugin . plugin , * args ) if hook . has_self else args result = hook . impl ( * plugin_args , ** kwargs ) if inspect . iscoroutine ( result ): results . append ( await result ) else : results . append ( result ) return self . _get_results ( results ) class SimplugHooks : DOCS \"\"\"The hooks manager Methods in this class are prefixed with a underscore to attributes clean for hooks. To call a hook in your system: >>> simplug.hooks.<hook_name>(<args>) Attributes: _registry: The plugin registry _specs: The registry for the hook specs _registry_sorted: Whether the plugin registry has been sorted already \"\"\" def __init__ ( self ): self . _registry = OrderedDiot () # type: OrderedDiot self . _specs = {} # type: Dict[str, SimplugHook] self . _registry_sorted = False # type: bool def _register ( self , plugin : SimplugWrapper ) -> None : \"\"\"Register a plugin (already wrapped by SimplugWrapper) Args: plugin: The plugin wrapper Raises: HookRequired: When a required hook is not implemented HookSignatureDifferentFromSpec: When the arguments of a hook implementation is different from its specification \"\"\" if ( plugin . name in self . _registry and plugin != self . _registry [ plugin . name ]): raise PluginRegistered ( f 'Another plugin named { plugin . name } ' 'has already been registered.' ) # check if required hooks implemented # and signature for specname , spec in self . _specs . items (): hook = plugin . hook ( specname ) if spec . required and hook is None : raise HookRequired ( f ' { specname } , but not implemented ' f 'in plugin { plugin . name } ' ) if hook is None : continue impl_params = list ( inspect . signature ( hook . impl ) . parameters . keys ()) spec_params = list ( inspect . signature ( spec . spec ) . parameters . keys ()) if impl_params [ 0 ] == 'self' : impl_params = impl_params [ 1 :] if spec_params [ 0 ] == 'self' : spec_params = spec_params [ 1 :] if impl_params != spec_params : raise HookSignatureDifferentFromSpec ( f ' { specname !r} in plugin { plugin . name } \\n ' f 'Expect { spec_params } , ' f 'but got { impl_params } ' ) if ( isinstance ( spec , SimplugHookAsync ) and spec . warn_sync_impl_on_async and not inspect . iscoroutinefunction ( hook . impl )): warnings . warn ( f \"Sync implementation on async hook \" f \" { specname !r} in plugin { plugin . name } \" , SyncImplOnAsyncSpecWarning ) self . _registry [ plugin . name ] = plugin def _sort_registry ( self ) -> None : \"\"\"Sort the registry by the priority only once\"\"\" if self . _registry_sorted : return orderedkeys = self . _registry . __diot__ [ 'orderedkeys' ] self . _registry . __diot__ [ 'orderedkeys' ] = sorted ( orderedkeys , key = lambda plug : self . _registry [ plug ] . priority ) self . _registry_sorted = True def __getattr__ ( self , name : str ) -> \"SimplugHook\" : DOCS \"\"\"Get the hook by name Args: name: The hook name Returns: The SimplugHook object Raises: NoSuchHookSpec: When the hook has no specification defined. \"\"\" try : return self . _specs [ name ] except KeyError as exc : raise NoSuchHookSpec ( name ) . with_traceback ( exc . __traceback__ ) from None class SimplugContext : DOCS \"\"\"The context manager for enabling or disabling a set of plugins\"\"\" def __init__ ( self , simplug : \"Simplug\" , plugins : Optional [ Iterable [ Any ]]): self . plugins = plugins if plugins is not None : self . simplug = simplug self . orig_registry = simplug . hooks . _registry . copy () self . orig_status = { name : plugin . enabled for name , plugin in self . orig_registry . items ()} def __enter__ ( self ): if self . plugins is None : return orig_registry = self . orig_registry . copy () # raw orig_names = list ( orig_registry . keys ()) orig_raws = [ plugin . plugin for plugin in orig_registry . values ()] for plugin in self . plugins : if isinstance ( plugin , str ) and plugin in orig_registry : orig_registry [ plugin ] . enable () del orig_registry [ plugin ] elif plugin in orig_registry . values (): plugin . enable () del orig_registry [ plugin . name ] elif plugin in orig_raws : name = orig_names [ orig_raws . index ( plugin )] orig_registry [ name ] . enable () del orig_registry [ name ] else : self . simplug . register ( plugin ) for plugin in orig_registry . values (): plugin . disable () def __exit__ ( self , * exc ): if self . plugins is None : return self . simplug . hooks . _registry = self . orig_registry for name , status in self . orig_status . items (): self . simplug . hooks . _registry [ name ] . enabled = status class _SimplugContextOnly ( SimplugContext ): \"\"\"The context manager with only given plugins enabled\"\"\" class _SimplugContextBut ( SimplugContext ): \"\"\"The context manager with only given plugins disabled\"\"\" def __enter__ ( self ): if self . plugins is None : return orig_registry = self . orig_registry . copy () # raw orig_names = list ( orig_registry . keys ()) orig_raws = [ plugin . plugin for plugin in orig_registry . values ()] for plugin in self . plugins : if isinstance ( plugin , str ) and plugin in orig_registry : orig_registry [ plugin ] . disable () del orig_registry [ plugin ] elif plugin in orig_registry . values (): plugin . disable () del orig_registry [ plugin . name ] elif plugin in orig_raws : name = orig_names [ orig_raws . index ( plugin )] orig_registry [ name ] . disable () del orig_registry [ name ] # ignore plugin not existing for plugin in orig_registry . values (): plugin . enable () class Simplug : DOCS \"\"\"The plugin manager for simplug Attributes: PROJECTS: The projects registry, to make sure the same `Simplug` object by the name project name. _batch_index: The batch index for plugin registration hooks: The hooks manager _inited: Whether `__init__` has already been called. Since the `__init__` method will be called after `__new__`, this is used to avoid `__init__` to be called more than once \"\"\" PROJECTS : Dict [ str , \"Simplug\" ] = {} def __new__ ( cls , project : str ) -> \"Simplug\" : if project not in cls . PROJECTS : obj = super () . __new__ ( cls ) obj . __init__ ( project ) cls . PROJECTS [ project ] = obj return cls . PROJECTS [ project ] def __init__ ( self , project : str ): if getattr ( self , '_inited' , None ): return self . _batch_index = 0 self . hooks = SimplugHooks () self . project = project self . _inited = True def load_entrypoints ( self , group : Optional [ str ] = None ): DOCS \"\"\"Load plugins from setuptools entry_points\"\"\" group = group or self . project for dist in importlib_metadata . distributions (): for epoint in dist . entry_points : if epoint . group != group : continue plugin = epoint . load () self . register (( plugin , epoint . name )) def register ( self , * plugins : Any ) -> None : DOCS \"\"\"Register plugins Args: *plugins: The plugins, each of which could be a str, indicating that the plugin is a module and will be imported by `__import__`; or an object with the hook implementations as its attributes. \"\"\" for i , plugin in enumerate ( plugins ): plugin = SimplugWrapper ( plugin , self . _batch_index , i ) self . hooks . _register ( plugin ) self . _batch_index += 1 def get_plugin ( self , name : str , raw : bool = False ) -> object : DOCS \"\"\"Get the plugin wrapper or the raw plugin object Args: name: The name of the plugin raw: Get the raw plugin object (the one when it's registered) If a plugin is a module and registered by its name, the module is returned Raises: NoSuchPlugin: When the plugin does not exist Returns: The plugin wrapper or raw plugin \"\"\" if name not in self . hooks . _registry : raise NoSuchPlugin ( name ) wrapper = self . hooks . _registry [ name ] return wrapper . plugin if raw else wrapper def get_all_plugins ( self , DOCS raw : bool = False ) -> Dict [ str , SimplugWrapper ]: \"\"\"Get a mapping of all plugins Args: raw: Whether return the raw plugin or not (the one when it's registered) If a plugin is registered as a module by its name, the module is returned. Returns: The mapping of all plugins \"\"\" if not raw : return self . hooks . _registry return OrderedDiot ([( name , plugin . plugin ) for name , plugin in self . hooks . _registry . items ()]) def get_enabled_plugins ( self , DOCS raw : bool = False ) -> Dict [ str , SimplugWrapper ]: \"\"\"Get a mapping of all enabled plugins Args: raw: Whether return the raw plugin or not (the one when it's registered) If a plugin is registered as a module by its name, the module is returned. Returns: The mapping of all enabled plugins \"\"\" return OrderedDiot ([( name , plugin . plugin if raw else plugin ) for name , plugin in self . hooks . _registry . items () if plugin . enabled ]) def get_all_plugin_names ( self ) -> List [ str ]: DOCS \"\"\"Get the names of all plugins Returns: The names of all plugins \"\"\" return list ( self . hooks . _registry . keys ()) def get_enabled_plugin_names ( self ) -> List [ str ]: DOCS \"\"\"Get the names of all enabled plugins Returns: The names of all enabled plugins \"\"\" return [ name for name , plugin in self . hooks . _registry . items () if plugin . enabled ] def plugins_only_context ( DOCS self , plugins : Optional [ Iterable [ Any ]] ) -> _SimplugContextOnly : \"\"\"A context manager with only given plugins enabled Args: plugins: The plugin names or plugin objects If the given plugin does not exist, register it. None to not enable or disable anything Returns: The context manager \"\"\" return _SimplugContextOnly ( self , plugins ) def plugins_but_context ( DOCS self , plugins : Optional [ Iterable [ Any ]] ) -> _SimplugContextBut : \"\"\"A context manager with all plugins but given plugins enabled Args: *plugins: The plugin names or plugin objects to exclude If the given plugin does not exist, ignore it Returns: The context manager \"\"\" return _SimplugContextBut ( self , plugins ) def enable ( self , * names : str ) -> None : DOCS \"\"\"Enable plugins by names Args: *names: The names of the plugin \"\"\" for name in names : self . get_plugin ( name ) . enable () def disable ( self , * names : str ) -> None : DOCS \"\"\"Disable plugins by names Args: names: The names of the plugin \"\"\" for name in names : self . get_plugin ( name ) . disable () def spec ( self , DOCS hook : Optional [ Callable ] = None , required : bool = False , result : SimplugResult = SimplugResult . ALL_BUT_NONE , warn_sync_impl_on_async : bool = True ) -> Callable : \"\"\"A decorator to define the specification of a hook Args: hook: The hook spec. If it is None, that means this decorator is called with arguments, and it should be keyword arguments. Otherwise, it is called like this `simplug.spec` required: Whether this hook is required to be implemented. result: How should we collect the results from the plugins Raises: HookSpecExists: If a hook spec with the same name (`hook.__name__`) is already defined. Returns: A decorator function of other argument is passed, or the hook spec itself. \"\"\" def decorator ( hook_func : Callable ): hook_name = hook_func . __name__ if hook_name in self . hooks . _specs : raise HookSpecExists ( hook_name ) if inspect . iscoroutinefunction ( hook_func ): self . hooks . _specs [ hook_name ] = SimplugHookAsync ( self . hooks , hook_func , required , result , warn_sync_impl_on_async ) else : self . hooks . _specs [ hook_name ] = SimplugHook ( self . hooks , hook_func , required , result ) return hook_func return decorator ( hook ) if hook else decorator def impl ( self , hook : Callable ): DOCS \"\"\"A decorator for the implementation of a hook Args: hook: The hook implementation Raises: NoSuchHookSpec: When no specification is defined for this hook Returns: The wrapped hook implementation by `SimplugImpl` \"\"\" if hook . __name__ not in self . hooks . _specs : raise NoSuchHookSpec ( hook . __name__ ) return SimplugImpl ( hook , 'self' in inspect . signature ( hook ) . parameters )","title":"simplug"}]}